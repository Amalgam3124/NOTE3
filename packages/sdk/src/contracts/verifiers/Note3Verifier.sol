// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./base/BaseVerifier.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

enum VerifierType {
    TEE,
    ZKP
}

contract Note3Verifier is BaseVerifier {
    address public immutable attestationContract;
    VerifierType public immutable verifierType;

    constructor(address _attestationContract, VerifierType _verifierType) {
        attestationContract = _attestationContract;
        verifierType = _verifierType;
    }

    function hashNonce(bytes memory nonce) private pure returns (bytes32) {
        return keccak256(nonce);
    }

    /// @notice Verify preimage of data, the _proof prove:
    ///         for public data, the proof is knowing the pre-image of dataHashes
    ///         for private data, the proof is knowing the pre-image of dataHashes and the plaintext of the pre-image
    ///         if preimage proof is not required, the proof is the data itself âœ…
    /// @param proofs Proof generated by TEE
    function verifyPreimage(
        bytes[] calldata proofs
    ) external pure override returns (PreimageProofOutput[] memory) {
        PreimageProofOutput[] memory outputs = new PreimageProofOutput[](
            proofs.length
        );
        for (uint256 i = 0; i < proofs.length; i++) {
            require(proofs[i].length == 32, "Invalid data hash length");
            bytes32 dataHash = bytes32(proofs[i]);

            bool isValid = true;

            outputs[i] = PreimageProofOutput(dataHash, isValid);
        }
        return outputs;
    }

    /// @notice Extract and verify signature from the accessibility proof
    /// @param accessibilityProof The signature proof
    /// @param isPrivate Whether the data is private
    /// @param newDataHash The hash of the new data
    /// @param oldDataHash The hash of the old data (for private data only)
    /// @return The recovered signer address
    function verifyAccessibility(
        bytes memory accessibilityProof,
        bool isPrivate,
        bytes memory nonce,
        bytes32 newDataHash,
        bytes32 oldDataHash
    ) private pure returns (address) {
        require(
            accessibilityProof.length == 65,
            "Invalid accessibility proof length"
        );

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(accessibilityProof, 32))
            s := mload(add(accessibilityProof, 64))
            v := byte(0, mload(add(accessibilityProof, 96)))
        }

        bytes32 messageHash = createMessageHash(isPrivate, newDataHash, oldDataHash, nonce);

        return ecrecover(messageHash, v, r, s);
    }

    /// @notice Create the message hash for signature verification
    /// @param isPrivate Whether the data is private
    /// @param newDataHash The hash of the new data
    /// @param oldDataHash The hash of the old data (for private data only)
    /// @return The message hash
    function createMessageHash(
        bool isPrivate,
        bytes32 newDataHash,
        bytes32 oldDataHash,
        bytes memory nonce
    ) private pure returns (bytes32) {
        bytes32 messageHex;
        if (isPrivate) {
            messageHex = keccak256(
                abi.encodePacked(
                    newDataHash,
                    oldDataHash,
                    nonce
                )
            );
        } else {
            messageHex = keccak256(
                abi.encodePacked(
                    newDataHash,
                    nonce
                )
            );
        }
        string memory message = Strings.toHexString(uint256(messageHex), 32);
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n66", message));
    }

    /// @notice Process a single transfer validity proof
    /// @param proof The proof data
    /// @return output The processed proof data as a struct
    function processTransferProof(
        bytes calldata proof
    ) private view returns (TransferValidityProofOutput memory output) {
        // Parse the indicator
        bool isTEE = (uint8(proof[0]) & 0x80) == 0;
        require(
            isTEE == (verifierType == VerifierType.TEE),
            "Incorrect verifier type"
        );

        bool isPrivate = (uint8(proof[0]) & 0x40) != 0;

        // Extract accessibility proof
        bytes memory accessibilityProof = proof[1:66];

        // Extract nonce for accessibility proof
        bytes memory nonce = proof[66:114];

        // Extract hashes
        output.newDataHash = bytes32(proof[114:146]);

        if (isPrivate) {
            output.oldDataHash = bytes32(proof[146:178]);
            output.sealedKey = bytes16(proof[178:190]);
        }

        output.receiver = verifyAccessibility(
            accessibilityProof,
            isPrivate,
            nonce,
            output.newDataHash,
            output.oldDataHash
        );
        bool isAccess = output.receiver != address(0);

        // TODO: verify the proofs
        // 1. verify TEE's signature
        bool isValid = true;
        if (isPrivate) {
            // verify ownership proof
            // remember to verify the key to encrypt the sealedKey is receiver's pubKey
            // verifyOwnershipProof(ownershipProof, isTEE, output.newDataHash, output.oldDataHash, output.sealedKey);
        }

        output.isValid = isValid && isAccess;
        return output;
    }

    /// @notice Verify data transfer validity, the _proof prove:
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted with the receiver's pubKey to get the sealedKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: TEE could support a private key of the receiver)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proofs Proof generated by TEE
    /// The first 1 bit is the proof type, 0 for TEE, 1 for ZKP
    /// The second 1 bit is the proof type, 0 for public data, 1 for private data
    /// The 2~7 bits are reserved for future use
    /// The 1~65 bytes are the accessibility proof
    /// The 66~98 bytes are the newDataHashes
    /// If private data, 99~131 bytes are the oldDataHashes
    /// If private data, 132~144 bytes are the sealedKey
    /// If private data, the rest of the proof from the oracle
    function verifyTransferValidity(
        bytes[] calldata proofs
    ) public virtual returns (TransferValidityProofOutput[] memory) {
        TransferValidityProofOutput[]
            memory outputs = new TransferValidityProofOutput[](proofs.length);

        for (uint256 i = 0; i < proofs.length; i++) {
            TransferValidityProofOutput memory output = processTransferProof(
                proofs[i]
            );

            // Create the output
            outputs[i] = output;

            // TODO: defend against replay attack
            bytes32 proofNonce = hashNonce(proofs[i][66:114]);
            _checkAndMarkProof(proofNonce);
        }

        return outputs;
    }
}
